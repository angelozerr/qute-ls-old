/* Generated by: JavaCC 21 Parser Generator. QUTEParser.java */
package qute;

@SuppressWarnings("unused")
public class QUTEParser implements QUTEConstants {
    private boolean buildTree=true;
    private boolean tokensAreNodes=true;
    private boolean specialTokensAreNodes=true;
    private java.util.ArrayList<Node>nodes=new java.util.ArrayList<Node>();
    private java.util.ArrayList<java.lang.Integer>marks=new java.util.ArrayList<java.lang.Integer>();
    private int mark;
    // current mark
    private boolean node_created;
    /** 
     * Determines whether the current node was actually closed and
     * pushed.  This should only be called in the final user action of a
     * node scope.  
     */
    public boolean nodeCreated() {
        return node_created;
    }

    /** 
	 * Returns the root node of the AST.  It only makes sense to call
	 * this after a successful parse. 
	 */
    public Node rootNode() {
        return nodes.get(0);
    }

    /**
     * push a node onto the top of the node stack
     */
    public void pushNode(Node n) {
        nodes.add(n);
    }

    /** 
     * Returns the node on the top of the stack, and remove it from the
     * stack.  
     */
    public Node popNode() {
        return nodes.remove(nodes.size()-1);
    }

    /** 
     * Returns the node currently on the top of the stack. 
     */
    public Node peekNode() {
        return nodes.get(nodes.size()-1);
    }

    /**
     * Puts the node on the top of the stack. However, unlike pushNode()
     * it replaces the node that is currently on the top of the stack.
     * This is effectively equivalent to popNode() followed by pushNode(n)
     */
    public void pokeNode(Node n) {
        pokeNode(n,false);
    }

    /**
     * Puts the node on the top of the stack. If clearNodeScope is true,
     * it removes all the nodes in the current node scope and pushes
     * n onto the top. Otherwise, it simply replaces the node at the
     * top of the stack with n.
     */
    public void pokeNode(Node n,boolean clearNodeScope) {
        if (clearNodeScope) {
            clearNodeScope();
            nodes.add(n);
        }
        else {
            nodes.set(nodes.size()-1,n);
        }
    }

    /** Returns the number of children on the stack in the current node
	 * scope. 
	 */
    public int nodeArity() {
        return nodes.size()-mark;
    }

    public void clearNodeScope() {
        while (nodes.size()>mark) {
            popNode();
        }
    }

    public void openNodeScope(Node n) {
        marks.add(mark);
        mark=nodes.size();
        n.open();
    }

    /* A definite node is constructed from a specified number of
	 * children.  That number of nodes are popped from the stack and
	 * made the children of the definite node.  Then the definite node
	 * is pushed on to the stack. */
    public void closeNodeScope(Node n,int num) {
        mark=marks.remove(marks.size()-1);
        java.util.ArrayList<Node>nodes=new java.util.ArrayList<Node>();
        for(int i=0; 
        i<num; 
        i++) {
            nodes.add(popNode());
        }
        java.util.Collections.reverse(nodes);
        for(Node child : nodes) {
            if (specialTokensAreNodes&&(child instanceof Token)) {
                Token token=(Token) child;
                Token specialToken=token;
                while (specialToken!=null) {
                    specialToken=specialToken.specialToken;
                }
                while (specialToken!=null&&specialToken!=token) {
                    n.addChild(specialToken);
                    specialToken=specialToken.next;
                }
            }
            n.addChild(child);
        }
        n.close();
        pushNode(n);
        node_created=true;
    }

    /** 
	 * A conditional node is constructed if its condition is true.  All
	 * the nodes that have been pushed since the node was opened are
	 * made children of the conditional node, which is then pushed
	 * on to the stack.  If the condition is false the node is not
	 * constructed and they are left on the stack. 
	 */
    public void closeNodeScope(Node n,boolean condition) {
        if (condition) {
            int a=nodeArity();
            mark=marks.remove(marks.size()-1);
            java.util.ArrayList<Node>nodes=new java.util.ArrayList<Node>();
            while (a-->0) {
                nodes.add(popNode());
            }
            java.util.Collections.reverse(nodes);
            for(Node child : nodes) {
                if (specialTokensAreNodes&&(child instanceof Token)) {
                    Token token=(Token) child;
                    Token specialToken=token;
                    while (specialToken.specialToken!=null) {
                        specialToken=specialToken.specialToken;
                    }
                    while (specialToken!=null&&specialToken!=token) {
                        n.addChild(specialToken);
                        specialToken=specialToken.next;
                    }
                }
                n.addChild(child);
            }
            n.close();
            pushNode(n);
            node_created=true;
        }
        else {
            mark=marks.remove(marks.size()-1);
            node_created=false;
        }
    }

    public boolean getBuildTree() {
        return buildTree;
    }

    public void setBuildTree(boolean buildTree) {
        this.buildTree=buildTree;
    }

    /**
     * Just a kludge so that existing jjtree-based code that uses
     * parser.jjtree.foo can work without change.
     */
    QUTEParser jjtree=this;
    /** Generated Lexer. */
    public QUTELexer token_source;
    SimpleCharStream jj_input_stream;
    public void setInputSource(String inputSource) {
        token_source.setInputSource(inputSource);
    }

    String getInputSource() {
        return token_source.getInputSource();
    }

    Token current_token;
    /** Next token. */
    private Token jj_nt;
    private int jj_ntk;
    private int jj_gen;
    final private int[] jj_la1=new int[10];
    static private int[] jj_la1_0;
    static private int[] jj_la1_1;
    static {
        jj_la1_init_0();
        jj_la1_init_1();
    }
    private static void jj_la1_init_0() {
        jj_la1_0=new int[]{0x6110,0x1000000,0x2000000,0xc00000,0x6110,0x8800000,0x80000000,0x4380000,0x4380000,0x4380000};
    }

    private static void jj_la1_init_1() {
        jj_la1_1=new int[]{0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0};
    }

    public QUTEParser(java.io.InputStream stream) {
        this(new java.io.InputStreamReader(stream));
    }

    public QUTEParser(java.io.Reader stream) {
        jj_input_stream=new SimpleCharStream(stream,1,1);
        token_source=new QUTELexer(jj_input_stream);
        current_token=new Token();
        jj_ntk=-1;
        for(int i=0; 
        i<10; 
        i++) jj_la1[i]=-1; 
    }

    /** Constructor with generated Token Manager. */
    public QUTEParser(QUTELexer tm) {
        token_source=tm;
        current_token=new Token();
        jj_ntk=-1;
        for(int i=0; 
        i<10; 
        i++) jj_la1[i]=-1; 
    }

    private Token jj_consume_token(int kind) throws ParseException {
        Token oldToken=current_token;
        if (current_token.next!=null) current_token=current_token.next;
        else current_token=current_token.next=token_source.getNextToken();
        jj_ntk=-1;
        if (current_token.kind==kind) {
            jj_gen++;
            if (buildTree&&tokensAreNodes) {
                pushNode(current_token);
            }
            return current_token;
        }
        current_token=oldToken;
        jj_kind=kind;
        throw generateParseException();
    }

    /** Get the next Token. */
    final public Token getNextToken() {
        if (current_token.next!=null) current_token=current_token.next;
        else current_token=current_token.next=token_source.getNextToken();
        jj_ntk=-1;
        jj_gen++;
        return current_token;
    }

    /** Get the specific Token. */
    final public Token getToken(int index) {
        Token t=current_token;
        for(int i=0; 
        i<index; 
        i++) {
            if (t.next!=null) t=t.next;
            else t=t.next=token_source.getNextToken();
        }
        return t;
    }

    private int jj_ntk() {
        if ((jj_nt=current_token.next)==null) return(jj_ntk=(current_token.next=token_source.getNextToken()).kind);
        else return(jj_ntk=jj_nt.kind);
    }

    private java.util.ArrayList<int[]>jj_expentries=new java.util.ArrayList<int[]>();
    private int[] jj_expentry;
    private int jj_kind=-1;
    public ParseException generateParseException() {
        jj_expentries.clear();
        boolean[] la1tokens=new boolean[33];
        if (jj_kind>=0) {
            la1tokens[jj_kind]=true;
            jj_kind=-1;
        }
        for(int i=0; 
        i<10; 
        i++) {
            if (jj_la1[i]==jj_gen) {
                for(int j=0; 
                j<32; 
                j++) {
                    if ((jj_la1_0[i]&(1<<j))!=0) {
                        la1tokens[0+j]=true;
                    }
                    if ((jj_la1_1[i]&(1<<j))!=0) {
                        la1tokens[32+j]=true;
                    }
                }
            }
        }
        for(int i=0; 
        i<33; 
        i++) {
            if (la1tokens[i]) {
                jj_expentry=new int[1];
                jj_expentry[0]=i;
                jj_expentries.add(jj_expentry);
            }
        }
        int[][] exptokseq=new int[jj_expentries.size()][];
        for(int i=0; 
        i<jj_expentries.size(); 
        i++) {
            exptokseq[i]=(int[]) jj_expentries.get(i);
        }
        return new ParseException(current_token,exptokseq,tokenImage);
    }

    /** Enable tracing. */
    final public void enable_tracing() {
    }

    /** Disable tracing. */
    final public void disable_tracing() {
    }

    // QEL.javacc, line 49
    final public void Expression() throws ParseException {
        // QEL.javacc, line 51
        Expression node1=null;
        if (buildTree) {
            node1=new Expression();
            Token jjtStartToken=getToken(1);
            node1.setBeginLine(jjtStartToken.beginLine);
            node1.setBeginColumn(jjtStartToken.beginColumn);
            node1.setInputSource(this.getInputSource());
            openNodeScope(node1);
        }
        boolean hitException1=false;
        try {
            switch((jj_ntk==-1)?jj_ntk():
            jj_ntk) {
                case C_IDENTIFIER:
                // QEL.javacc, line 51
                // QEL.javacc, line 51
                jj_consume_token(C_IDENTIFIER);
                break;
                case STRING_LITERAL:
                // QEL.javacc, line 53
                // QEL.javacc, line 53
                jj_consume_token(STRING_LITERAL);
                break;
                case NUMBER:
                // QEL.javacc, line 55
                // QEL.javacc, line 55
                jj_consume_token(NUMBER);
                break;
                case OPEN_PAREN:
                // QEL.javacc, line 57
                // QEL.javacc, line 57
                Parenthesis();
                break;
                default:
                jj_la1[0]=jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        catch(Exception e1) {
            hitException1=false;
            if (e1 instanceof ParseException) throw(ParseException) e1;
            if (e1 instanceof RuntimeException) throw(RuntimeException) e1;
            throw new RuntimeException(e1);
        }
        finally {
            if (buildTree) {
                if (!hitException1) {
                    closeNodeScope(node1,nodeArity()>1);
                    Token jjtEndToken=getToken(0);
                    node1.setEndLine(jjtEndToken.endLine);
                    node1.setEndColumn(jjtEndToken.endColumn);
                }
                else {
                    clearNodeScope();
                    mark=marks.remove(marks.size()-1);
                }
            }
        }
    }

    // QEL.javacc, line 60
    final public void Parenthesis() throws ParseException {
        // QEL.javacc, line 62
        Parenthesis node2=null;
        if (buildTree) {
            node2=new Parenthesis();
            Token jjtStartToken=getToken(1);
            node2.setBeginLine(jjtStartToken.beginLine);
            node2.setBeginColumn(jjtStartToken.beginColumn);
            node2.setInputSource(this.getInputSource());
            openNodeScope(node2);
        }
        boolean hitException2=false;
        try {
            // QEL.javacc, line 62
            jj_consume_token(OPEN_PAREN);
            // QEL.javacc, line 63
            Expression();
            // QEL.javacc, line 64
            jj_consume_token(CLOSE_PAREN);
        }
        catch(Exception e2) {
            hitException2=false;
            if (e2 instanceof ParseException) throw(ParseException) e2;
            if (e2 instanceof RuntimeException) throw(RuntimeException) e2;
            throw new RuntimeException(e2);
        }
        finally {
            if (buildTree) {
                if (!hitException2) {
                    closeNodeScope(node2,nodeArity()>1);
                    Token jjtEndToken=getToken(0);
                    node2.setEndLine(jjtEndToken.endLine);
                    node2.setEndColumn(jjtEndToken.endColumn);
                }
                else {
                    clearNodeScope();
                    mark=marks.remove(marks.size()-1);
                }
            }
        }
    }

    // QUTE.javacc, line 59
    final public void Interpolation() throws ParseException {
        // QUTE.javacc, line 61
        Interpolation node3=null;
        if (buildTree) {
            node3=new Interpolation();
            Token jjtStartToken=getToken(1);
            node3.setBeginLine(jjtStartToken.beginLine);
            node3.setBeginColumn(jjtStartToken.beginColumn);
            node3.setInputSource(this.getInputSource());
            openNodeScope(node3);
        }
        boolean hitException3=false;
        try {
            // QUTE.javacc, line 61
            jj_consume_token(OPEN_CURLY);
            // QUTE.javacc, line 61
            Expression();
            // QUTE.javacc, line 61
            jj_consume_token(CLOSE_CURLY);
        }
        catch(Exception e3) {
            hitException3=false;
            if (e3 instanceof ParseException) throw(ParseException) e3;
            if (e3 instanceof RuntimeException) throw(RuntimeException) e3;
            throw new RuntimeException(e3);
        }
        finally {
            if (buildTree) {
                if (!hitException3) {
                    closeNodeScope(node3,nodeArity()>1);
                    Token jjtEndToken=getToken(0);
                    node3.setEndLine(jjtEndToken.endLine);
                    node3.setEndColumn(jjtEndToken.endColumn);
                }
                else {
                    clearNodeScope();
                    mark=marks.remove(marks.size()-1);
                }
            }
        }
    }

    // QUTE.javacc, line 64
    final public void IfBlock() throws ParseException {
        // QUTE.javacc, line 66
        IfBlock node4=null;
        if (buildTree) {
            node4=new IfBlock();
            Token jjtStartToken=getToken(1);
            node4.setBeginLine(jjtStartToken.beginLine);
            node4.setBeginColumn(jjtStartToken.beginColumn);
            node4.setInputSource(this.getInputSource());
            openNodeScope(node4);
        }
        boolean hitException4=false;
        try {
            // QUTE.javacc, line 66
            jj_consume_token(IF);
            // QUTE.javacc, line 67
            Expression();
            // QUTE.javacc, line 68
            jj_consume_token(CLOSE_CURLY);
            // QUTE.javacc, line 69
            Block();
            // QUTE.javacc, line 70
            label_1:
            while (true) {
                int int1=(jj_ntk==-1)?jj_ntk():
                jj_ntk;
                if (!(int1==ELSEIF)) {
                    jj_la1[1]=jj_gen;
                    break label_1;
                }
                // QUTE.javacc, line 70
                // QUTE.javacc, line 70
                ElseIfBlock();
            }
            // QUTE.javacc, line 71
            int int2=(jj_ntk==-1)?jj_ntk():
            jj_ntk;
            if (int2==ELSE) {
                // QUTE.javacc, line 71
                // QUTE.javacc, line 71
                ElseBlock();
            }
            else {
                jj_la1[2]=jj_gen;
            }
            // QUTE.javacc, line 72
            switch((jj_ntk==-1)?jj_ntk():
            jj_ntk) {
                case ENDIF:
                // QUTE.javacc, line 72
                // QUTE.javacc, line 72
                jj_consume_token(ENDIF);
                break;
                case ABBREVIATED_END:
                // QUTE.javacc, line 72
                // QUTE.javacc, line 72
                jj_consume_token(ABBREVIATED_END);
                break;
                default:
                jj_la1[3]=jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        catch(Exception e4) {
            hitException4=false;
            if (e4 instanceof ParseException) throw(ParseException) e4;
            if (e4 instanceof RuntimeException) throw(RuntimeException) e4;
            throw new RuntimeException(e4);
        }
        finally {
            if (buildTree) {
                if (!hitException4) {
                    closeNodeScope(node4,nodeArity()>1);
                    Token jjtEndToken=getToken(0);
                    node4.setEndLine(jjtEndToken.endLine);
                    node4.setEndColumn(jjtEndToken.endColumn);
                }
                else {
                    clearNodeScope();
                    mark=marks.remove(marks.size()-1);
                }
            }
        }
    }

    // QUTE.javacc, line 75
    final public void ElseIfBlock() throws ParseException {
        // QUTE.javacc, line 77
        ElseIfBlock node5=null;
        if (buildTree) {
            node5=new ElseIfBlock();
            Token jjtStartToken=getToken(1);
            node5.setBeginLine(jjtStartToken.beginLine);
            node5.setBeginColumn(jjtStartToken.beginColumn);
            node5.setInputSource(this.getInputSource());
            openNodeScope(node5);
        }
        boolean hitException5=false;
        try {
            // QUTE.javacc, line 77
            jj_consume_token(ELSEIF);
            // QUTE.javacc, line 78
            Expression();
            // QUTE.javacc, line 79
            jj_consume_token(CLOSE_CURLY);
            // QUTE.javacc, line 80
            Block();
        }
        catch(Exception e5) {
            hitException5=false;
            if (e5 instanceof ParseException) throw(ParseException) e5;
            if (e5 instanceof RuntimeException) throw(RuntimeException) e5;
            throw new RuntimeException(e5);
        }
        finally {
            if (buildTree) {
                if (!hitException5) {
                    closeNodeScope(node5,nodeArity()>1);
                    Token jjtEndToken=getToken(0);
                    node5.setEndLine(jjtEndToken.endLine);
                    node5.setEndColumn(jjtEndToken.endColumn);
                }
                else {
                    clearNodeScope();
                    mark=marks.remove(marks.size()-1);
                }
            }
        }
    }

    // QUTE.javacc, line 83
    final public void ElseBlock() throws ParseException {
        // QUTE.javacc, line 85
        ElseBlock node6=null;
        if (buildTree) {
            node6=new ElseBlock();
            Token jjtStartToken=getToken(1);
            node6.setBeginLine(jjtStartToken.beginLine);
            node6.setBeginColumn(jjtStartToken.beginColumn);
            node6.setInputSource(this.getInputSource());
            openNodeScope(node6);
        }
        boolean hitException6=false;
        try {
            // QUTE.javacc, line 85
            jj_consume_token(ELSE);
            // QUTE.javacc, line 86
            Block();
        }
        catch(Exception e6) {
            hitException6=false;
            if (e6 instanceof ParseException) throw(ParseException) e6;
            if (e6 instanceof RuntimeException) throw(RuntimeException) e6;
            throw new RuntimeException(e6);
        }
        finally {
            if (buildTree) {
                if (!hitException6) {
                    closeNodeScope(node6,nodeArity()>1);
                    Token jjtEndToken=getToken(0);
                    node6.setEndLine(jjtEndToken.endLine);
                    node6.setEndColumn(jjtEndToken.endColumn);
                }
                else {
                    clearNodeScope();
                    mark=marks.remove(marks.size()-1);
                }
            }
        }
    }

    // QUTE.javacc, line 89
    final public void Section() throws ParseException {
        // QUTE.javacc, line 91
        Section node7=null;
        if (buildTree) {
            node7=new Section();
            Token jjtStartToken=getToken(1);
            node7.setBeginLine(jjtStartToken.beginLine);
            node7.setBeginColumn(jjtStartToken.beginColumn);
            node7.setInputSource(this.getInputSource());
            openNodeScope(node7);
        }
        boolean hitException7=false;
        try {
            // QUTE.javacc, line 91
            jj_consume_token(START_SECTION);
            // QUTE.javacc, line 91
            int int3=(jj_ntk==-1)?jj_ntk():
            jj_ntk;
            if (int3==C_IDENTIFIER||int3==STRING_LITERAL||int3==NUMBER||int3==OPEN_PAREN) {
                // QUTE.javacc, line 91
                // QUTE.javacc, line 91
                Expression();
            }
            else {
                jj_la1[4]=jj_gen;
            }
            // QUTE.javacc, line 93
            switch((jj_ntk==-1)?jj_ntk():
            jj_ntk) {
                case CLOSE_EMPTY:
                // QUTE.javacc, line 93
                // QUTE.javacc, line 93
                jj_consume_token(CLOSE_EMPTY);
                break;
                case CLOSE_CURLY:
                // QUTE.javacc, line 95
                // QUTE.javacc, line 96
                // QUTE.javacc, line 96
                jj_consume_token(CLOSE_CURLY);
                // QUTE.javacc, line 97
                Block();
                // QUTE.javacc, line 99
                switch((jj_ntk==-1)?jj_ntk():
                jj_ntk) {
                    case END_SECTION:
                    // QUTE.javacc, line 99
                    // QUTE.javacc, line 99
                    jj_consume_token(END_SECTION);
                    break;
                    case ABBREVIATED_END:
                    // QUTE.javacc, line 99
                    // QUTE.javacc, line 99
                    jj_consume_token(ABBREVIATED_END);
                    break;
                    default:
                    jj_la1[5]=jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
                }
                break;
                default:
                jj_la1[6]=jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        catch(Exception e7) {
            hitException7=false;
            if (e7 instanceof ParseException) throw(ParseException) e7;
            if (e7 instanceof RuntimeException) throw(RuntimeException) e7;
            throw new RuntimeException(e7);
        }
        finally {
            if (buildTree) {
                if (!hitException7) {
                    closeNodeScope(node7,nodeArity()>1);
                    Token jjtEndToken=getToken(0);
                    node7.setEndLine(jjtEndToken.endLine);
                    node7.setEndColumn(jjtEndToken.endColumn);
                }
                else {
                    clearNodeScope();
                    mark=marks.remove(marks.size()-1);
                }
            }
        }
    }

    // QUTE.javacc, line 105
    final public void Block() throws ParseException {
        // QUTE.javacc, line 107
        Block node8=null;
        if (buildTree) {
            node8=new Block();
            Token jjtStartToken=getToken(1);
            node8.setBeginLine(jjtStartToken.beginLine);
            node8.setBeginColumn(jjtStartToken.beginColumn);
            node8.setInputSource(this.getInputSource());
            openNodeScope(node8);
        }
        boolean hitException8=false;
        try {
            // QUTE.javacc, line 115
            label_2:
            while (true) {
                // QUTE.javacc, line 108
                switch((jj_ntk==-1)?jj_ntk():
                jj_ntk) {
                    case TEXT:
                    // QUTE.javacc, line 108
                    // QUTE.javacc, line 108
                    jj_consume_token(TEXT);
                    break;
                    case OPEN_CURLY:
                    // QUTE.javacc, line 110
                    // QUTE.javacc, line 110
                    Interpolation();
                    break;
                    case IF:
                    // QUTE.javacc, line 112
                    // QUTE.javacc, line 112
                    IfBlock();
                    break;
                    case START_SECTION:
                    // QUTE.javacc, line 114
                    // QUTE.javacc, line 114
                    Section();
                    break;
                    default:
                    jj_la1[7]=jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
                }
                int int4=(jj_ntk==-1)?jj_ntk():
                jj_ntk;
                if (!(int4==TEXT||int4==OPEN_CURLY||int4==IF||int4==START_SECTION)) {
                    jj_la1[8]=jj_gen;
                    break label_2;
                }
            }
        }
        catch(Exception e8) {
            hitException8=false;
            if (e8 instanceof ParseException) throw(ParseException) e8;
            if (e8 instanceof RuntimeException) throw(RuntimeException) e8;
            throw new RuntimeException(e8);
        }
        finally {
            if (buildTree) {
                if (!hitException8) {
                    closeNodeScope(node8,nodeArity()>1);
                    Token jjtEndToken=getToken(0);
                    node8.setEndLine(jjtEndToken.endLine);
                    node8.setEndColumn(jjtEndToken.endColumn);
                }
                else {
                    clearNodeScope();
                    mark=marks.remove(marks.size()-1);
                }
            }
        }
    }

    // QUTE.javacc, line 119
    final public void Root() throws ParseException {
        // QUTE.javacc, line 121
        Root node9=null;
        if (buildTree) {
            node9=new Root();
            Token jjtStartToken=getToken(1);
            node9.setBeginLine(jjtStartToken.beginLine);
            node9.setBeginColumn(jjtStartToken.beginColumn);
            node9.setInputSource(this.getInputSource());
            openNodeScope(node9);
        }
        boolean hitException9=false;
        try {
            // QUTE.javacc, line 121
            int int5=(jj_ntk==-1)?jj_ntk():
            jj_ntk;
            if (int5==TEXT||int5==OPEN_CURLY||int5==IF||int5==START_SECTION) {
                // QUTE.javacc, line 121
                // QUTE.javacc, line 121
                Block();
            }
            else {
                jj_la1[9]=jj_gen;
            }
            // QUTE.javacc, line 122
            jj_consume_token(0);
        }
        catch(Exception e9) {
            hitException9=false;
            if (e9 instanceof ParseException) throw(ParseException) e9;
            if (e9 instanceof RuntimeException) throw(RuntimeException) e9;
            throw new RuntimeException(e9);
        }
        finally {
            if (buildTree) {
                if (!hitException9) {
                    closeNodeScope(node9,nodeArity()>1);
                    Token jjtEndToken=getToken(0);
                    node9.setEndLine(jjtEndToken.endLine);
                    node9.setEndColumn(jjtEndToken.endColumn);
                }
                else {
                    clearNodeScope();
                    mark=marks.remove(marks.size()-1);
                }
            }
        }
    }

}
